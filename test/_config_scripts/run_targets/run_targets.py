import os
import subprocess
import webbrowser
import argparse
import yaml

# Funkcja do wczytywania konfiguracji z pliku YAML
def load_config(yaml_file):
    with open(yaml_file, 'r') as file:
        return yaml.safe_load(file)

# Funkcja do tworzenia wymaganej struktury folderów
def create_required_directories(config):
    """
    Tworzy wymaganą strukturę folderów na podstawie pliku YAML.
    """
    base_report_path = "../../../reports"
    ccm_path = os.path.join(base_report_path, "CCM")
    ccr_path = os.path.join(base_report_path, "CCR")
    json_all_path = os.path.join(ccr_path, "JSON_ALL")
    ccr_html_out_path = os.path.join(json_all_path, "HTML_OUT")

    # Tworzenie folderów bazowych
    os.makedirs(base_report_path, exist_ok=True)
    os.makedirs(ccm_path, exist_ok=True)
    os.makedirs(ccr_path, exist_ok=True)
    os.makedirs(json_all_path, exist_ok=True)
    os.makedirs(ccr_html_out_path, exist_ok=True)

    # Tworzenie podfolderów dla każdego modułu
    for module in config.get('modules', []):
        module_name = module['name']
        module_path = os.path.join(ccr_path, module_name)
        os.makedirs(module_path, exist_ok=True)

    print(f"Struktura folderów została wygenerowana w '{os.path.abspath(base_report_path)}'.")
# Funkcja sprawdzająca czy usunąć zbudowane wcześniej konfiguracje
def check_reconfiguration_flag(rp_flag, module_path):

    out_path = os.path.join(module_path, 'out')

    if (rp_flag & os.path.isdir(out_path)):
        print("Flaga reconfigure_project została podana. Usuwam poprzednią kofigurację projektu jeśli istnieje...")
        # Komenda do wykonania
        command = ["rm", "-r", "out"]
        subprocess.run(command, cwd=module_path, check=True)

# Funkcja do uruchamiania targetów w folderze "out"
def run_make_targets(module_path, targets):

    out_path = os.path.join(module_path, 'out')

    if os.path.isdir(out_path):
        print(f"Folder 'out' w module {module_path} znaleziony")
    else:
        print(f"Brak folderu 'out' w module {module_path}.")
        print(f"Uruchamiamy Cmake dla modułu {module_path}.")
        # Komenda do wykonania
        command = ["cmake", "-S./", "-B", "out", "-G", "Unix Makefiles"]
        subprocess.run(command, cwd=module_path, check=True)
    
    print(f"Przechodzimy do folderu {out_path}")
    # command = ["cmake", "-S./","-G", "Unix Makefiles"]
    # subprocess.run(command, cwd=module_path, check=True)

    for target in targets:
        print(f"Uruchamianie 'make {target}' w {out_path}")
        subprocess.run(['make', target], cwd=out_path, check=True)

# Funkcja do generowania strony informacyjnej o braku raportu
def generate_missing_report_page(report_folder):
    """
    Tworzy wspólną stronę HTML informującą o braku raportu dla modułu.
    Strona jest tworzona tylko raz, nawet jeśli brak raportu występuje dla wielu modułów.
    """
    missing_report_path = os.path.join(report_folder, 'missing_report.html')

    if not os.path.exists(missing_report_path):  # Sprawdzamy, czy strona już istnieje
        with open(missing_report_path, 'w', encoding='utf-8') as f:
            f.write('''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Missing Code Complexity Report</title>
  <style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
    }
    h2 {
        margin-top: 20px;
    }
    p {
        font-size: 16px;
    }
    footer {
        margin-top: 20px;
        font-size: 12px;
        color: #555;
    }
  </style>
 </head>
 <body>
    <h2>Missing Code Complexity Report for This Module</h2>
    <p>
        A Code Complexity Metrics (CCMR) report has not been generated for this module. Please check if the 
        <strong>ccmr</strong> target is being executed for this module or if it is properly configured to generate the report.
    </p>
    <footer>
        Generated by update_all_reports.py
    </footer>
 </body>
</html>
''')
        print(f"Informational page about the missing report has been created at {missing_report_path}")
    else:
        print(f"Informational page about the missing report already exists at {missing_report_path}")


def generate_main_report(report_folder, modules_yaml_file):
    """
    Generuje główny raport Code Coverage i zapisuje go jako index.html.
    Zapisuje raport bez otwierania go.
    """
    with open(modules_yaml_file, 'r') as yaml_file:
        config_data = yaml.safe_load(yaml_file)
    
    modules = config_data['modules']

    # Ścieżka do strony głównej raportu
    main_report_path = os.path.join(report_folder, 'index.html')

    # Tworzymy główną stronę HTML
    with open(main_report_path, 'w', encoding='utf-8') as f:
        f.write('''<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>Project Code Complexity Reports Main Page</title>
  <style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        margin: 0;
        padding: 0;
    }
    h2 {
        margin-top: 20px;
    }
    ul {
        list-style-type: none;
        padding: 0;
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 10px;
        max-width: 80%;  /* Maksymalna szerokość kontenera */
        margin: 0 auto;  /* Wyśrodkowanie siatki */
    }
    li {
        margin: 10px 0;
    }
    a {
        text-decoration: none;  /* Usuwamy podkreślenie linku */
    }
    .report-button {
        display: inline-block;
        padding: 15px 25px;  /* Zwiększenie wysokości i szerokości przycisku */
        margin: 5px;
        background-color: #007BFF;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        width: 100%;  /* Przyciski mają 100% szerokości w siatce */
        text-align: center;
        font-size: 16px;
        box-sizing: border-box;
    }
    .report-button:hover {
        background-color: #0056b3;
    }
    .report-button-missing {
        background-color: #999;  /* Ciemniejszy szary */
    }
    .report-button-missing:hover {
        background-color: #777;  /* Ciemniejszy szary */
    }
    footer {
        margin-top: 20px;
        font-size: 12px;
        color: #555;
    }

    /* Responsywność */
    @media screen and (max-width: 1000px) {
        ul {
            grid-template-columns: repeat(3, 1fr);  /* 3 przyciski na wiersz */
        }
    }

    @media screen and (max-width: 600px) {
        ul {
            grid-template-columns: repeat(2, 1fr);  /* 2 przyciski na wiersz */
        }
    }

    @media screen and (max-width: 400px) {
        ul {
            grid-template-columns: 1fr;  /* 1 przycisk na wiersz */
        }
    }
  </style>
 </head>
 <body>
    <h2>Project Code Complexity Reports</h2>
    <ul>
''')

        # Iterujemy po nazwach modułów z pliku YAML
        for module in modules:
            module_name = module['name']
            report_file = f"{module_name}.html"  # Nazwa pliku HTML na podstawie nazwy modułu

            # Ścieżka do pliku HTML odpowiadającego modułowi
            file_path = os.path.join(report_folder, report_file)

            # Sprawdzamy, czy plik HTML dla modułu istnieje, ignorując wielkość liter
            files_in_directory = os.listdir(report_folder)  # Pobieramy listę plików w folderze
            matching_files = [f for f in files_in_directory if f.lower() == report_file.lower()]

            if matching_files:
                # Sprawdzamy pełną ścieżkę do pliku
                file_path = os.path.join(report_folder, matching_files[0])
                print(f"Znaleziono raport dla modułu: {module_name} w {file_path}")
                # Generujemy przycisk z nazwą modułu
                # Teraz linki są względne, zamiast pełnej ścieżki
                f.write(f'<li><a href="{matching_files[0]}"><button class="report-button">{module_name}</button></a></li>\n')
            else:
                print(f"Brak pliku dla modułu: {module_name} w {report_folder}")
                # Generujemy przycisk prowadzący do wspólnej strony o braku raportu
                missing_report_path = 'missing_report.html'
                f.write(f'<li><a href="{missing_report_path}"><button class="report-button report-button-missing">{module_name}</button></a></li>\n')

        f.write('''    </ul>
    <footer>
        Generated by update_all_reports.py script configured with config.yaml
    </footer>
 </body>
</html>
''')

    print(f"Zapisano główny raport w {main_report_path}")


# Funkcja do otwierania pliku HTML w domyślnej przeglądarce
def open_html_files_in_default_browser(reports):
    """
    Otwiera raporty w domyślnej przeglądarce systemu, w nowych zakładkach.
    """
    for report in reports:
        try:
            webbrowser.open(f"file://{os.path.abspath(report)}", new=2)
        except Exception as e:
            print(f"Błąd przy otwieraniu raportu {report}: {e}")

def main():
    # Ustawiamy parser argumentów
    parser = argparse.ArgumentParser(
        description=(
            "Skrypt do zarządzania konfiguracją i operacjami związanymi z projektem. "
            "Pozwala na wczytywanie ustawień z pliku YAML oraz wykonywanie dodatkowych operacji, "
            "takich jak ponowna konfiguracja projektu."
            )
    )

    parser.add_argument(
        '-c', '--config', 
        default='config.yaml', 
        help='Ścieżka do pliku YAML z konfiguracją (domyślnie: config.yaml)'
    )

    parser.add_argument(
        '-rp', '--reconfigure_project',
        action='store_true',
        help='Jeśli flaga jest podana, wykonaj operacje związane z ponowną konfiguracją projektu.'
    )

    # Parsujemy argumenty
    args = parser.parse_args()

    # Wczytujemy konfigurację z pliku YAML
    config = load_config(args.config)
    print("Załadowana konfiguracja:", args.config)

    create_required_directories(config)

    test_folder = '../../../test'

    # Wczytujemy listę raportów, które mają być wyświetlane z pliku YAML
    reports_to_open = []

    reports_to_show = config.get('reports_to_show', [])
    
    for report in reports_to_show:
        if report.lower() == 'ccm':
            reports_to_open.append("../../../reports/CCM/lcd_hd44780.html")
        elif report.lower() == 'ccr':
            reports_to_open.append("../../../reports/CCR/lcd_hd44780_report.html")
        else:
            # Dla innych raportów, traktujemy je jako pełne ścieżki
            if os.path.exists(report):
                reports_to_open.append(report)
            else:
                print(f"Nie znaleziono raportu pod ścieżką: {report}")

    # Iterujemy po wszystkich modułach
    for module in config['modules']:
        module_name = module['name']
        targets = module['targets']
        module_path = os.path.join(test_folder, module_name)
        
        if os.path.isdir(module_path):
            print(f"Zaczynamy dla modułu: {module_path}")
            check_reconfiguration_flag(args.reconfigure_project, module_path)
            run_make_targets(module_path, targets)
        else:
            print(f"Folder {module_path} nie istnieje.")

    # Tworzymy stronę informacyjną o braku raportów
    generate_missing_report_page("../../../reports/CCM")

    # Generujemy raporty
    generate_main_report("../../../reports/CCM", "config.yaml")

    # Otwieramy raporty
    if reports_to_open:
        open_html_files_in_default_browser(reports_to_open)

    print("Skrypt zakończony.")

if __name__ == "__main__":
    main()
